%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% CMPT 435
% Fall 2021
% Lab One
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Short Sectioned Assignment
% LaTeX Template
% Version 1.0 (5/5/12)
%
% This template has been downloaded from: http://www.LaTeXTemplates.com
% Original author: % Frits Wenneker (http://www.howtotex.com)
% License: CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
% Modified by Alan G. Labouseur  - alan@labouseur.com
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[letterpaper, 10pt,DIV=13]{scrartcl} 

\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyph
\usepackage[english]{babel} % English language/hyphenation
\usepackage{amsmath,amsfonts,amsthm,xfrac} % Math packages
\usepackage{sectsty} % Allows customizing section commands
\usepackage{graphicx}
\usepackage[lined,linesnumbered,commentsnumbered]{algorithm2e}
\usepackage{listings}
\usepackage{parskip}
\usepackage{lastpage}

\allsectionsfont{\normalfont\scshape} % Make all section titles in default font and small caps.

\usepackage{fancyhdr} % Custom headers and footers
\pagestyle{fancyplain} % Makes all pages in the document conform to the custom headers and footers

\fancyhead{} % No page header - if you want one, create it in the same way as the footers below
\fancyfoot[L]{} % Empty left footer
\fancyfoot[C]{} % Empty center footer
\fancyfoot[R]{page \thepage\ of \pageref{LastPage}} % Page numbering for right footer

\renewcommand{\headrulewidth}{0pt} % Remove header underlines
\renewcommand{\footrulewidth}{0pt} % Remove footer underlines
\setlength{\headheight}{13.6pt} % Customize the height of the header

\numberwithin{equation}{section} % Number equations within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{figure}{section} % Number figures within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{table}{section} % Number tables within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)

\setlength\parindent{0pt} % Removes all indentation from paragraphs.

\binoppenalty=3000
\relpenalty=3000

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} % Create horizontal rule command with 1 argument of height

\title{	
   \normalfont \normalsize 
   \textsc{CMPT 435 - Fall 2021 - Dr. Labouseur} \\[10pt] % Header stuff.
   \horrule{0.5pt} \\[0.25cm] 	% Top horizontal rule
   \huge Assignment Five  \\     	    % Assignment title
   \horrule{0.5pt} \\[0.25cm] 	% Bottom horizontal rule
}

\author{Shannon Cordoni \\ \normalsize Shannon.Cordoni@Marist.edu}

\date{\normalsize\today} 	% Today's date.

\begin{document}
\maketitle % Print the title

%----------------------------------------------------------------------------------------
%   start PROBLEM ONE
%----------------------------------------------------------------------------------------
\section{Problem One: Graphs and Greedy Algorithms}

\subsection{The Data Structure}
\paragraph{} Given multiple text files we were to create different directed graph representations and a fractional knapsack representation using Greedy Algorithms. First taking a list of graph instructions we were to create vertices and edges to form a directed graph in the form of linked objects to run the Bellman-Ford Algorithm to determine the single source shortest path. Then taking a list of spices to run the fractional knapsack representation using Greedy Algorithms.\\


\subsection{Main Class}

\subsubsection{Description}
\paragraph{}This class is where most of our work is done, it contains multiple scanners to read in our multiple files. These files include the $graphs2.txt$ file, and $spice.txt$ file. Using these files we input each line of the $graphs2.txt$ into an instruction array to be split up into a 2 dimensional array to access each index. We then use this split array to create the linked object representation for each graph. The $spice.txt$ file was also read into an array to be passed to the $spiceItUp$ method to create spice and knapsack objects to run the Greedy Algorithm. The methods contained in this class preform all these operations and more. 

\lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt, basicstyle=\footnotesize\ttfamily}
\begin{lstlisting}[frame=single, ] 
   
/*
 * 
 * Assignment 5
 * Due Date and Time: 12/10/21 before 12:00am 
 * Purpose: to implement directed graphs and greedy algorithm structures.
 * Input: The user will be inputting a file containing a list of edges and vertices. 
 * Output: The program will output direct graph shortest paths and greedy algorithms. 
 * @author Shannon Cordoni 
 * 
 */

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.*;
import java.util.Scanner;
import java.util.Collections;



public class Assignment5Cordoni {

    //Declare keyboard 
    static Scanner keyboard = new Scanner(System.in);
    
    public static void main(String[] args) {

        //Declare and initialize variables 
        String line;


        String[] spicearray = new String[14];
        String[] instructionarray = new String[88];
        String[][] splitinstructionarray = new String[88][17];

        //Reads in the spice items 
        //create new file object
        File myFile = new File("spice.txt");
        
        try
        {
            //create scanner
            Scanner input = new Scanner(myFile);
            line = null;
            
            int i = 0;

            //while there are more lines in the file it inputs them into a spice array
            while(input.hasNext())
            {  
                spicearray[i] = input.nextLine();       
                i++;
            }//while

            input.close();  

        }//try

        //General error message
        catch(Exception ex)
        {
            System.out.println("Something went wrong");
            ex.printStackTrace();
        }//catch

        //Reads in the graph file to create graphs 
        //create new file object
        File myFile1 = new File("graphs2.txt");
        
        try
        {
            //create scanner
            Scanner input = new Scanner(myFile1);
            line = null;
            
            int i = 0;

            //while there are more lines in the file it inputs them into an instruction array
            while(input.hasNext()){

                instructionarray[i] = input.nextLine();
                i++;
            }//while
  
            input.close();  

        }//try
        
        //General error message
        catch(Exception ex)
        {
            System.out.println("Something went wrong");
            ex.printStackTrace();
        }//catch

        //Spices!

        //Print to check array 
        for (int i = 0; i < spicearray.length; i++){
            //System.out.println(spicearray[i]);
        }//for

        //pass the spice array to the spiceItUp method to create the spice objects
        spiceItUp(spicearray);


        //Graphs!!

        //Print to check array 
        for (int i = 0; i < instructionarray.length; i++){
           //System.out.println(instructionarray[i]);
        }//for

        //split up into 2D array 
        for (int i = 0; i < splitinstructionarray.length; i++){
            for( int j = 0; j < splitinstructionarray[i].length; j++){
            splitinstructionarray[i] = instructionarray[i].split(" ");
            }//for j 
        }//for

        //pass the instruction array to the graphItUp method to create the vertex and edge 
        //objects for each graph
        graphItUp(splitinstructionarray);

    }//main

    //This method creates the linked objects of the directed graph
    //This also includes making a new graph object for each graph in the file
    //along with creating the edges and vertexes for each of these graphs
    public static void graphItUp(String[][] instructions) {

        GraphCordoni graphCordoni  = null; // new GraphCordoni();
        int k = 1;

        //create 
        for (int i = 0; i < instructions.length; i++){    
            
            //if the line reads new we create a new graph
            if(instructions[i][0].compareToIgnoreCase("new")==0){
                
                //if the graph is null we know its the first graph in the file
                if (graphCordoni == null){
                    graphCordoni = new GraphCordoni();
                    System.out.println("  ");
                    System.out.println("  ");
                    System.out.println("Graph " + k);
                    k++;
                }//if
                
                //else we know that we need to clear the graph object so we run the bellman 
                //ford method and reset graphCordoni
                //to hold the new graph
                else{

                    bellmanFord(graphCordoni, graphCordoni.edges.get(0).getWeight(),  
                    graphCordoni.vertexes.get(0));

                    graphCordoni = new GraphCordoni();
                    System.out.println("  ");
                    System.out.println("  ");
                    System.out.println("Graph " + k);
                    k++;

                }//else

            }//if

            //here we add the vertexes and edges
            else if (instructions[i][0].compareToIgnoreCase("add")==0){

                

                //create new vertex and set id to add to vertex array
                if(instructions[i][1].compareToIgnoreCase("vertex")==0){

                    VertexCordoni vertex = new VertexCordoni();

                    vertex.setId(instructions[i][2]);
                        
                    //add the vertex to the vertex array list
                    graphCordoni.vertexes.add(vertex);
                    
                    
                }//if
                
                //create new edge and set id to add to edge array
                else if(instructions[i][1].compareToIgnoreCase("edge")==0){
        
                    EdgeCordoni edge = new EdgeCordoni();

                    for (int j = 0; j < graphCordoni.vertexes.size(); j++){

                        //set the "from" of the edge 
                        if (graphCordoni.vertexes.get(j).getId()
                        .compareToIgnoreCase(instructions[i][2])==0){
                            edge.setFrom(graphCordoni.vertexes.get(j));
                        }//if

                        //set the "to" of the edge 
                        if (graphCordoni.vertexes.get(j).getId()
                        .compareToIgnoreCase(instructions[i][4])==0){
                            edge.setTo(graphCordoni.vertexes.get(j));
                        }//if
                    
                    }//for
                    
                    
                    //set the weight of the edge
                    if ((instructions[i][5].compareToIgnoreCase("") == 0)){
                        edge.setWeight(Integer.parseInt(instructions[i][6]));
                    }
                    
                    else{
                        edge.setWeight(Integer.parseInt(instructions[i][5]));
                    }//else

                    //add the edge to the edge array list
                    graphCordoni.edges.add(edge);

                }//else if
            }//else if
        }//for i

        /*
        for(int i = 0; i < graphCordoni.edges.size(); i++){

            System.out.println(" ");
            System.out.println("From: "  + graphCordoni.edges.get(i).getFrom().getId());
            System.out.println("To: "  + graphCordoni.edges.get(i).getTo().getId());
            System.out.println("Weight: "  + graphCordoni.edges.get(i).getWeight());
            System.out.println(" ");

        }//for
        // */

        //call the bellman ford algorithm
        bellmanFord(graphCordoni, graphCordoni.edges.get(0).getWeight(),
        graphCordoni.vertexes.get(0));
    }//graph it up 


    //This method preforms the bellman ford algorithm to find the shortest path
    public static boolean bellmanFord(GraphCordoni graph, int weight, VertexCordoni source) {
 
        //System.out.println("bellman ford");

        //call the single source method to set the distances to positive infinity
        singlesource(graph, source);

        boolean value = false;

        //for each vertex we loop through the edges to relax them
        for (int i = 0; i < graph.vertexes.size() - 1; i++){

            for (int j = 0; j < graph.edges.size(); j++){

                //System.out.println("relax");

                //here we call relax to "relax" each of the vertex distances down to their 
                //lowest possible distance
                relax(graph.edges.get(j).getFrom(), graph.edges.get(j).getTo(),
                graph.edges.get(j).getWeight());  
            
                /*
                System.out.println(" ");
                System.out.println("From: "  + graph.edges.get(j).getFrom().getId());
                System.out.println("To: "  + graph.edges.get(j).getTo().getId());
                System.out.println("Weight: "  + graph.edges.get(j).getWeight());
                System.out.println(" ");

                */
                
            }//for 

        }//for

        //here we loop through each edge to see if the from distance is greated than the to 
        //distances plus the weight.
        for (int i = 0; i < graph.edges.size(); i++){

            //System.out.println(" ");
            //System.out.println("From Distance:"+graph.edges.get(i).getFrom().getDistance());
            //System.out.println("To Distance: "  + graph.edges.get(i).getTo().getDistance());
            //System.out.println("Weight: "  + graph.edges.get(i).getWeight());
            //System.out.println(" ");

            
            if(graph.edges.get(i).getFrom().getDistance() >
            graph.edges.get(i).getTo().getDistance() + graph.edges.get(i).getWeight() ){
                value = false;
                shortestPath(value, graph);
                return value;
            
            }//if
            
        }//for
   
        value = true;

        shortestPath(value, graph);

        return value;

    }//BellmanFord

    //This method sets the initial single source
    public static void singlesource(GraphCordoni graph, VertexCordoni source) {

        //System.out.println("single source ");

        //here we loop through each of the vertexes setting their distance to positive 
        //infinity
        for (int i = 0; i < graph.vertexes.size(); i++){

            graph.vertexes.get(i).setDistance(Double.POSITIVE_INFINITY);

            graph.vertexes.get(i).setPrevious(null);
        
        }//for

        //set the distance of the source vertex to 0
        source.setDistance(0.0);
    
    }//singlesource

    //This method "relaxes" the vertex distance to determine the shortest path
    public static void relax(VertexCordoni vertexEdgeFrom, VertexCordoni vertexEdgeTo, 
                            Integer weight) {

        //System.out.println("relax");

        //System.out.println(" ");
        //System.out.println("Vertex"+vertexEdgeFrom.getId()+" distance:"
        +vertexEdgeFrom.getDistance());
        //System.out.println("Vertex"+vertexEdgeTo.getId()+" distance:"
        +vertexEdgeTo.getDistance());
        //System.out.println("Weight: "  + weight);
        //System.out.println(" ");

        //if the to vertex distance is greater than the from vertex distance then we set the 
        //to distance to 
        //be the from vertex distance plus the weight
        if(vertexEdgeTo.getDistance() > vertexEdgeFrom.getDistance() + weight){

            vertexEdgeTo.setDistance(vertexEdgeFrom.getDistance() + weight);

            vertexEdgeTo.setPrevious(vertexEdgeFrom);

            //System.out.println("Relax vertex " + vertexEdgeTo.getId() + " to " 
            + vertexEdgeTo.getDistance());

        }//if

    }//relax

    //This method prints out the shortest path
    public static void shortestPath(boolean value, GraphCordoni graph) {

        //here we loop through the vertexes and print out the shortest path from the source 
        //vertex to the 
        //desired vertex
        for(int i = 0; i < graph.vertexes.size(); i++){

            VertexCordoni current = null;

            ArrayList <String> path = new ArrayList <String>();

            current = graph.vertexes.get(i);

            System.out.println(" ");
            System.out.println(" ");
            System.out.println("From " + graph.vertexes.get(0).getId() + " to " +
            graph.vertexes.get(i).getId() + " the cost is " 
            + graph.vertexes.get(i).getDistance());

            System.out.println("The path is ");

            
            //if the previous is set to null then we are at the source vertex
            if(graph.vertexes.get(i).getPrevious() == null){

                System.out.print(graph.vertexes.get(i).getId());

            
            }//if

            //else we start at the desired vertex and work our way backwards to determine our 
            //shortest path. basing this off of the answers for graph 1 I was able to get 
            //this working for all the paths 
            //except for the last vertex in each graph
            else{

                int j  = i;

                path.add(graph.vertexes.get(j).getId());
                //System.out.println(graph.vertexes.get(j).getId());

                while(graph.vertexes.get(j).getPrevious().getId() != 
                    graph.vertexes.get(0).getId()){
                    
 
                    //System.out.println(graph.vertexes.get(j).getPrevious().getId());
                    path.add(graph.vertexes.get(j).getPrevious().getId());
                    j++;
                    
                    //paths are correct besides last path for each graph
                    if(j == graph.vertexes.size()){
                        break;
                    }//if

                    
                }//while

                //System.out.println(graph.vertexes.get(0).getId());
                path.add(graph.vertexes.get(0).getId());

                Collections.reverse(path);

                for(int k = 0; k < path.size(); k++){

                    System.out.print(path.get(k));
                }//for k
                
            }//else

        }//for

    }//shortestPath

    
    //Spices!

    //This method creates the spice object
    public static void spiceItUp(String[] spices) {

        System.out.println("Spice Hesit!");
        System.out.println(" ");

        String[][] splitspicearray = new String[9][9];
        
        int j = 0;

        for (int i = 0; i < spices.length; i++){

            //if the line starts with spice then we split by ; and then by space
            if (spices[i].startsWith("spice")){
                
                //System.out.println(Arrays.toString(spices[i].split(";| ")));

                splitspicearray[j] = spices[i].split(";| ");
                j++;

            }//if

            //if the line starts with knapsack then we split by ; and then by space
            else if (spices[i].startsWith("knapsack")){

                //System.out.println(Arrays.toString(spices[i].split(";| ")));

                splitspicearray[j] = spices[i].split(";| ");
                j++;

            }//if
            
            
        }//for

        //print to check array
        for(int i  = 0; i < splitspicearray.length; i++){
            for(int k = 0; k < splitspicearray[i].length; k++){

                //System.out.println(splitspicearray[i][k]);

            }//for j
        }//for i

        //pass the created array to the create spice method to create the spice objects
        createSpice(splitspicearray);
    }//spiceitup

    //this method creates the spice objects
    public static void createSpice(String[][] spices) {

        ArrayList <SpiceCordoni> spicelist = new ArrayList <SpiceCordoni>();

        //increment index to create spice array
        for (int i = 0; i < spices.length; i++){

            //if the line starts with spice then we create a new spice object
            if (spices[i][0].compareToIgnoreCase("spice")==0){
                //System.out.println(" new spice ");

                SpiceCordoni spice = new SpiceCordoni();

                //System.out.println("color: " + spices[i][3]);

                spice.setColor(spices[i][3]);

                //if the line starts with total price then we set the total price of the 
                //spice object along with the qty of the spice object
                if(spices[i][8].trim().startsWith("total_price")){
                    
                    //System.out.println("price 1: " + spices[i][11].trim());

                    spice.setPrice(Double.parseDouble(spices[i][11].trim()));

                    //System.out.println("qty 1: " + spices[i][16]);

                    spice.setQty(Integer.parseInt(spices[i][16]));

                }//if

                else if(spices[i][6].trim().startsWith("total_price")){
                    //System.out.println("price 2: " + spices[i][8].trim());

                    spice.setPrice(Double.parseDouble(spices[i][8].trim()));

                    //System.out.println("qty 2: " + spices[i][13]);
                    spice.setQty(Integer.parseInt(spices[i][13]));

                }//else

                else if(spices[i][7].trim().startsWith("total_price")){
                    //System.out.println("price 3: " + spices[i][9].trim());

                    spice.setPrice(Double.parseDouble(spices[i][9].trim()));

                    //System.out.println("qty 3: " + spices[i][14]);
                    spice.setQty(Integer.parseInt(spices[i][14]));
                }//else

                else if(spices[i][5].trim().startsWith("total_price")){
                    //System.out.println("price 4: " + spices[i][7].trim());

                    spice.setPrice(Double.parseDouble(spices[i][7].trim()));

                    //System.out.println("qty 4: " + spices[i][12]);
                    spice.setQty(Integer.parseInt(spices[i][12]));
                }//else
 
                //here we dd the spice object to the spice list array
                spicelist.add(spice);
            }// if  
            
        }//for i
         
        
        //print spice to check
        //System.out.println(spicelist.toString());

        //pass the spicelist and spices array to the spice unit price method
        spiceUnitPrice(spicelist, spices);

    }//createSpice

    //This method creates each spice's unit price
    public static void spiceUnitPrice(ArrayList<SpiceCordoni> spicelist, String[][] spices) {
 
        //Create unit price for each spice
        for(int i = 0; i < spicelist.size(); i++){

            spicelist.get(i).setUnitPrice(spicelist.get(i).getPrice()/spicelist.get(i)
            .getQty());

        }//for

        //pass the spice list and spices array to the sort method
        sort(spicelist, spices);
    }//spiceUnitPrice

    //This method sorts spices from high to low unit price
    public static void sort(ArrayList<SpiceCordoni> spicelist, String[][] spices)
    {

        //reverse the spicelist to put them in order from highest to lowest unit price
        Collections.reverse(spicelist);

        //Check unit price for each spice
        for(int i = 0; i < spicelist.size(); i++){

            //System.out.println("Spice " + spicelist.get(i).getColor());
            //System.out.println("Price " + spicelist.get(i).getUnitPrice());

        }//for

        //pass the spicelist and spices array to the create knapsack method
        createKnapsack(spicelist, spices);

    }//sort

    //This method creates the knapsacks
    public static void createKnapsack(ArrayList<SpiceCordoni> spicelist, String[][] spices) {
 
        //create a knapsack arraylist
        ArrayList <KnapsackCordoni> knapsacklist = new ArrayList <KnapsackCordoni>();
        
        //increment index to create spice array
        for (int i = 0; i < spices.length; i++){

            //if the line starts with knapsack then we create a new knapsack object
            if (spices[i][0].compareToIgnoreCase("knapsack")==0){
                //System.out.println(" new knapsack ");

                KnapsackCordoni knapsack = new KnapsackCordoni();


                //set the capcity of the knapsack
                if (spices[i][3].trim().compareToIgnoreCase("")==0){

                    knapsack.setCapacity(Integer.parseInt(spices[i][4].trim()));
                            
                    knapsacklist.add(knapsack);

                }//if

                else{

                    knapsack.setCapacity(Integer.parseInt(spices[i][3].trim()));
                        
                    knapsacklist.add(knapsack);

                }//else
            }//if  
            
        }//for i
         
        //Create unit price for each spice
        for(int i = 0; i < knapsacklist.size(); i++){

            //System.out.println("Capacity " + knapsacklist.get(i).getCapacity());

        }//for

        //pass the spicelist and knapsack list to the fill knapsack method
        fillKnapsack(spicelist, knapsacklist);

    }//createKnapsack

    //This method fills the knapsacks
    public static void fillKnapsack( ArrayList<SpiceCordoni> spicelist, 
                                    ArrayList<KnapsackCordoni> knapsacklist) {
 
        int knapsackcapacity = 0 ;

        //for each knapsack in the list we fill it according to the greedy algorithm method
        for(int i = 0; i < knapsacklist.size(); i++){

            //get the knapsack capacity 
            knapsackcapacity = knapsacklist.get(i).getCapacity();

            //initialize variables so that they reset for each knapsack
            double worth = 0;
            int quantity = 0;
            int scoop = 0;
            String[] color = new String[20];
            int orangescoops = 0;
            int bluescoops = 0;
            int greenscoops = 0;
            int redscoops = 0;
            
            int k = 0;

            //for each spice in the spice list we get the qty and while the quantity is not 
            //0 and the scoop count
            //if less than the knapsack capacity then we add the spice and it's specific 
            //quantity to the knapsack
            for(int j = 0; j < spicelist.size(); j++){

                quantity = spicelist.get(j).getQty();

                //int k = 0;
                while((quantity != 0)&&(scoop < knapsackcapacity)){
                       
                    quantity = quantity - 1;
                    worth = worth + spicelist.get(j).getUnitPrice();
                    color[k] = spicelist.get(j).getColor();
                    //System.out.println(color[k]);
                    scoop++;

                    k++;

                    //System.out.println("k " + k);

                }//while

            }//for j

            //print out each knapsack and what its worth
            System.out.println("Knapsack of capacity " + knapsackcapacity + " is worth " 
                            + worth + " quatloos and contains ");
            
            //loop through the color array to see which colors (spices) are in each knapsack
            for(int l = 0; l < color.length; l++){
                //System.out.println(color[l]);
            }

            //if a color appears in the knapsack then we up the scoopcount for that color to 
            //determine how many scoops of each spice are in the knapsack
            for(int l = 0; l < color.length; l++){

                if((color[l] !=null)&&(color[l].compareToIgnoreCase("orange")==0)){
                    orangescoops++;
                }
                else if((color[l] !=null)&&(color[l].startsWith("blue"))){
                    bluescoops++;
                }
                if((color[l] !=null)&&(color[l].startsWith("green"))){
                    greenscoops++;
                }
                if((color[l] !=null)&&(color[l].startsWith("red"))){
                    redscoops++;
                }

            }//for

            //here we print out each color and the amount of scoops they have in each knapsack.
            for(int l = 0; l < color.length; l++){

                //System.out.println("orange scoops: " + orangescoops);

                //System.out.println("blue scoops: " + bluescoops);

                //System.out.println("green scoops: " + greenscoops);

                //System.out.println("red scoops: " + redscoops);

                //we go through each color like this because this way we get a hold of every 
                //color that appears
                //in each knapsack
                if(orangescoops != 0){
                    System.out.println(orangescoops + " scoop(s) of orange");

                    if(bluescoops != 0){
                        System.out.println(bluescoops + " scoop(s) of blue");
                        
                        if(greenscoops != 0){
                            System.out.println(greenscoops + " scoop(s) of green");

                            if(redscoops != 0){
                                System.out.println(redscoops + " scoop(s) of red");
                                
                            }//if
                        }//if
                    }//if

                    break;
                }//if
                else if(bluescoops != 0){
                    System.out.println(bluescoops + " scoop(s) of blue");

                    if(greenscoops != 0){
                        System.out.println(greenscoops + " scoop(s) of green");

                        if(redscoops != 0){
                            System.out.println(redscoops + " scoop(s) of red");
                            
                        }//if
                    }//if

                    break;
                }
                if(greenscoops != 0){
                    System.out.println(greenscoops + " scoop(s) of green");

                    if(redscoops != 0){
                        System.out.println(redscoops + " scoop(s) of red");
                        
                    }//if

                    break;
                }
                if(redscoops != 0){
                    System.out.println(redscoops + " scoop(s) of red");
                    break;
                }

            }//for
           
        }//for i   

    }//fillKnapsack

}//Assignment5Cordoni

\end{lstlisting}

\subsubsection{Description of Main Code}
\paragraph{} The main class above consists of different methods to help create directed graphs and their bellman-ford representations. Along with running a spice heist using Greedy Algorithms. The good parts of the code first include the file sections. While reading the different $txt$ files we input each line into arrays for each file. For the Graph representations we create an instruction array to pass to our graph methods to more easily create the graph representations. Along with passing each line of the spice array from the $spice.txt$ file into our spice methods to perform the spice heist. Then to keep everything out of the main method, different methods were used to help organize the code better. These methods include the $graphItUp$, $bellmanFord$, $singlesource$, $relax$, $shortestPath$, $spiceItUp$, $createSpice$, $spiceUnitPrice$, $sort$, $createKnapsack$, and $fillKnapsack$ method.

\paragraph{} The $graphItUp$ method takes in a 2 dimensional set of instructions from the main method and reads it line by line. If the line starts with "new" we create a new graph object to create vertexes and edges for. If the line starts with "vertex" then we create a new vertex for the graph and add it to the vertex array list of the graph. If the line starts with "edge" we get the "to" and "from" vertex and create a new edge for the graph and add it to the edge array list of the graph. We then call the bellman ford algorithm, and pass it the graph, the source vertexes weight, and the source vertex.

\paragraph{} The $bellmanFord$ method takes in a graph, a source vertex weight and a source vertex. First we call the $singlesource$ method to set the distance of each vertex to positive infinity. Then we go through each edge for each vertex and call the $relax$ method to in a sense "relax" the vertex distances down from positive infinity to determine the shortest path from the source vertex to each of the other vertexes in the graph. We then loop through the edges to determine if the "from" vertex distance is greater then the "to" vertex distance plus the weight of the edge. We cycle through until this returns false or we make it all the way through the edge array list. Either way we then call the  The $shortestPath$ method to then print out the shortest path from the source vertex to the desired vertex and the cost of this path.

\paragraph{} The $singlesource$ method takes in a graph and a source vertex and loops through each vertex in the graph setting its distance to positive infinity and its previous vertex to null. We also set the source vertex distance to be 0.

\paragraph{} The $relax$ method looks to see if the "to" vertex distance is greater than the "from" vertex distance plus the weight of the edge. If it is we set the "to" vertex distance to be equal to the "from" vertex distance plus the weight of the edge, and the previous vertex to be equal to the "from" vertex. If not then we go back to the bellman ford algorithm and call relax for the next set of vertices.

\paragraph{} The $shortestPath$ takes in a graph and a boolean value, the method goes through each vertex in the graphs array list and prints out the shortest path from the source vertex to the next vertex in the array list. If the previous of the current vertex is null then we are at the source vertex and we print the source vertex. Else we start at the current index and go through the previous vertexes until we end up back at the source vertex to print out the shortest path.

\paragraph{} The $spiceItUp$ method takes in an array of spice and knapsack information and we loop through this array, if the line starts with "spice" or "knapsack" then we add it to a separate array to be split up to create spice and knapsack objects. We then pass this split array to the $createSpice$ method.

\paragraph{} The $createSpice$ method goes through the spice information and sets the color, price, and qty of each new spice object. We then add each of the new spice objects to an array list to be passed along to the next methods, such as the $spiceUnitPrice$ method. 

\paragraph{} The $spiceUnitPrice$ method takes in the spice array list and the 2 dimensional array of spice information and we create and set the unit price for each spice object.

\paragraph{} The $sort$ method takes in the spice array list and the 2 dimensional array of spice information and sorts the unit price from high to low. We then passed this sorted list and the 2 dimensional array of spice information to the $createKnapsack$ method.

\paragraph{} The $createKnapsack$ method takes in the spice array list and the 2 dimensional array of spice information and creates the knapsack objects based off of the knapsack information in the spice array. After creating the knapsack objects we pass the spice array list and the knapsack array list to the $fillKnapsack$ method.

\paragraph{} The $fillKnapsack$ method takes in the spice array list and the knapsack array list. First we start by looping through the knapsack array list and for each knapsack we go through the spice array list and while the quantity of the spice is not equal to zero and the scoop count is less than the knapsack capacity we calculate the worth, color, and scoop count of each spice needed to fill the knapsack. We then print out the capacity, worth, and scoop count of each spice needed to fill each knapsack in the knapsack array list. 

\subsection{Edge Class}

\subsubsection{Description}
\paragraph{} For the creation of each edge in the directed graph we passed the edge data to the edge class to create each edge object. 

\lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt, basicstyle=\footnotesize\ttfamily}
\begin{lstlisting}[frame=single, ] 
/*
 * 
 * Assignment 5
 * Due Date and Time: 12/10/21 before 12:00am 
 * Purpose: to implement directed graphs and greedy algorithm structures.
 * Input: The user will be inputting a file containing a list of edges and vertices. 
 * Output: The program will output direct graph shortest paths and greedy algorithms. 
 * @author Shannon Cordoni 
 * 
 */

import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.ArrayList;

public class EdgeCordoni
{
   /**
    * Declare Variables 
    */
    private VertexCordoni myTo;
    private VertexCordoni myFrom;
    private int myWeight;


    /**
    * The default Constructor for EdgeCordoni
    */
   public EdgeCordoni()
   {
   myTo = null;
   myFrom = null;
   myWeight = 0;
   }//Edge Cordoni

    /**
    * The full constructor for NodeCordoni
    * @param newData the incoming data of the item
    */
    public EdgeCordoni(VertexCordoni newTo, VertexCordoni newFrom, Integer newWeight)
    {
        myTo = newTo;
        myFrom = newFrom;
        myWeight = newWeight;
        
    }//EdgeCordoni

    /**
    * the setter for the edge data
    * @param newTo the incoming data of the item
    */
    public void setTo(VertexCordoni newTo)
        {myTo = newTo;} //set data

    /**
     * The getter for the edge data
     * @return the incoming data of the item
     */
    public VertexCordoni getTo()
        {return myTo;}//get data

    /**
    * the setter for the edge data
    * @param newFrom the incoming data of the item
    */
    public void setFrom(VertexCordoni newFrom)
        {myFrom = newFrom;} //set data

    /**
     * The getter for the edge data
     * @return the incoming data of the item
     */
    public VertexCordoni getFrom()
        {return myFrom;}//get data

    /**
    * the setter for the edge data
    * @param newWeight the incoming data of the item
    */
    public void setWeight(Integer newWeight)
        {myWeight = newWeight;} //set data

    /**
     * The getter for the edge data
     * @return the incoming data of the item
     */
    public Integer getWeight()
        {return myWeight;}//get data


}//edge Cordoni
\end{lstlisting}

\subsubsection{Description of Edge Code}
\paragraph{} This code for the Edge Class was created by previous knowledge working with the Node Class. Using the same set up each Edge was given a to, from, and weight. Getters and setters were created for each to make creating the edges run more smoothly, along with adding them to the edge array list for each graph. 

\subsection{Graph Class}

\subsubsection{Description}
\paragraph{} For each graph in the text file, a graph object was created to organize all the vertices and edges of each graph.

\lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt, basicstyle=\footnotesize\ttfamily}
\begin{lstlisting}[frame=single, ]
/*
 * 
 * Assignment 5
 * Due Date and Time: 12/10/21 before 12:00am 
 * Purpose: to implement directed graphs and greedy algorithm structures.
 * Input: The user will be inputting a file containing a list of edges and vertices. 
 * Output: The program will output direct graph shortest paths and greedy algorithms. 
 * @author Shannon Cordoni 
 * 
 */

import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.ArrayList;

public class GraphCordoni
{
    /**
    * Declare Variables 
    */

    public  ArrayList <VertexCordoni> vertexes = new ArrayList <VertexCordoni>();
    public  ArrayList <EdgeCordoni> edges = new ArrayList <EdgeCordoni>();

}//Graph Cordoni
\end{lstlisting}

\subsubsection{Description of Graph Code}
\paragraph{} This code for the Graph Class was created by in class lessons but also previous knowledge from Software Development 1. Using this set up an array-list was created to hold the edges and vertices of each graph.



\subsection{Knapsack Class}

\subsubsection{Description}
\paragraph{} For each knapsack in the spice file a knapsack object was created to house the data for better organization.

\lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt, basicstyle=\footnotesize\ttfamily}
\begin{lstlisting}[frame=single, ]
/*
 * 
 * Assignment 5
 * Due Date and Time: 12/10/21 before 12:00am 
 * Purpose: to implement directed graphs and greedy algorithm structures.
 * Input: The user will be inputting a file containing a list of edges and vertices. 
 * Output: The program will output direct graph shortest paths and greedy algorithms. 
 * @author Shannon Cordoni 
 * 
 */

public class KnapsackCordoni{

    /**
    * Instance Variable 
    */
    private Integer myCapacity;
   
   /**
    * The default Constructor for KnapsackCordoni
    */
    public KnapsackCordoni()
    {
       myCapacity = 0;
    }//Knapsack Cordoni

     /**
    * The full constructor for KnapsackCordoni
    */
    public KnapsackCordoni(Integer newCapacity)
    {
        myCapacity = newCapacity;
        
    }//KnapsackCordoni
   

    /**
    * The setter for the knapsack
    * @param newCapacity the incoming knapsack data
    */
    public void setCapacity(Integer newCapacity)
    {myCapacity = newCapacity;}//set Qty

    /**
    * the getter for the knapsack data 
    * @return the incoming knapsack data
    */
    public Integer getCapacity()
    { return myCapacity;}//get node

}//knapsackCordoni
\end{lstlisting}

\subsubsection{Description of Knapsack Code}
\paragraph{} This code for the Knapsack Class was created by in class lessons but also previous knowledge from Software Development 1. Using this set up a capacity was set for each knapsack so that we could create knapsack objects.




\subsection{Vertex Class}

\subsubsection{Description}
\paragraph{} For each vertex in the graph an actual vertex object had to be created to hold it. This class creates the vertex object to be represented in the graph. This was so that the creation of the graph representations could run more smoothly and so that the edges could be added to help represent the graphs. 

\lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt, basicstyle=\footnotesize\ttfamily}
\begin{lstlisting}[frame=single, ]

/*
 * 
 * Assignment 5
 * Due Date and Time: 12/10/21 before 12:00am 
 * Purpose: to implement directed graphs and greedy algorithm structures.
 * Input: The user will be inputting a file containing a list of edges and vertices. 
 * Output: The program will output direct graph shortest paths and greedy algorithms. 
 * @author Shannon Cordoni 
 * 
 */

import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.ArrayList;

public class VertexCordoni
{
     /**
      * Declare Variables 
     */
     private String myId;
     private boolean myIsProcessed;
     public ArrayList <VertexCordoni> neighbors= new ArrayList <VertexCordoni>();
     private VertexCordoni myNext;
     private VertexCordoni myPrevious;
     private Double myDistance;
     

     /**
      * The default Constructor for VertexCordoni
     */
     public VertexCordoni()
     {
     myId = new String();
     myIsProcessed = false;
     myNext = null;
     myPrevious = null;
     myDistance = 0.0;
     }//vertex Cordoni

     /**
     * The full constructor for VertexCordoni
     * @param newData the incoming data 
     */
     public VertexCordoni(String newData)
     {
          myId = newData;
          myIsProcessed = false;
          myNext = null;
          myPrevious = null;
          myDistance = 0.0;
          
     }//NodeCordoni

    /**
     * 
    * the setter for the vertex id
    * @param newId the incoming data of the vertex
    */
    public void setId(String newId)
    {myId = newId;} //set data

    /**
    * The getter for the vertex id
    * @return the incoming data of the vertex
    */
    public String getId()
    {return myId;}//get data


    /**
    * 
    * the setter for the next vertex 
    * @param newNext the incoming data of the vertex
    */
    public void setNext(VertexCordoni newNext)
    {myNext = newNext;} //set data

    /**
    * The getter for the vertex 
    * @return the incoming data of the vertex
    */
    public VertexCordoni getNext()
    {return myNext;}//get data

    /**
    * 
    * the setter for the Previous vertex 
    * @param newPrevious the incoming data of the vertex
    */
    public void setPrevious(VertexCordoni newPrevious)
    {myPrevious = newPrevious;} //set data

    /**
    * The getter for the vertex 
    * @return the incoming data of the vertex
    */
    public VertexCordoni getPrevious()
    {return myPrevious;}//get data

    /**
    * The setter for the process status
    * @param newIsProcessed the incoming process status
    */
    public void setProcessStatus(boolean newIsProcessed)
    {myIsProcessed = newIsProcessed;}//set data

    /**
    * the getter for the process status
    * @return the incoming process status
    */
    public boolean getProcessStatus()
    { return myIsProcessed;}//get data

    /**
    * The setter for the Distance
    * @param newDistance the incoming Distance
    */
    public void setDistance(Double newDistance)
    {myDistance = newDistance;}//set data

    /**
    * the getter for the process status
    * @return the incoming process status
    */
    public Double getDistance()
    { return myDistance;}//get data

   
}//Vertex Cordoni

\end{lstlisting}

\subsubsection{Description of Vertex Code}
\paragraph{} This code for the Vertex Class was created by previous knowledge working with the Node Class. Using the same set up each Vertex was given an Id, process status, neighbor arraylist, next, previous, and distance. Getters and setters were created for each to make the creation of the vertexes and edges run more smoohtly. 

\subsection{Spice Class}

\subsubsection{Description}
\paragraph{} For each spice in the spice file a spice object was created so that we could create spice objects and run the Greedy Algorithm more smoothly.   

\lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt, basicstyle=\footnotesize\ttfamily}
\begin{lstlisting}[frame=single, ]
/*
 * 
 * Assignment 5
 * Due Date and Time: 12/10/21 before 12:00am 
 * Purpose: to implement directed graphs and greedy algorithm structures.
 * Input: The user will be inputting a file containing a list of edges and vertices. 
 * Output: The program will output direct graph shortest paths and greedy algorithms. 
 * @author Shannon Cordoni 
 * 
 */

public class SpiceCordoni{

    /**
    * Instance Variable 
    */
    private String myColor;
    private Double myPrice;
    private Integer myQty;
    private Double myUnitPrice;
   
   /**
    * The default Constructor for SpiceCordoni
    */
    public SpiceCordoni()
    {
       myColor = new String();
       myPrice = 0.0;
       myQty = 0;
       myUnitPrice = 0.0;
    }//Spice Cordoni
   

    /**
    * The full constructor for SpiceCordoni
    */
    public SpiceCordoni(String newColor, Double newPrice, Integer newQty, Double newUnitPrice)
    {
        myColor = newColor;
        myPrice = newPrice;
        myQty = newQty;
        myUnitPrice = newUnitPrice;
        
    }//SpiceCordoni

    /**
    * the setter for the spice data
    * @param newmyColor the incoming data of the spice
    */
    public void setColor(String newColor)
    {myColor = newColor;} //set Name

    /**
    * The getter for the spice data
    * @return the incoming data of the item
    */
    public String getColor()
    {return myColor;}//get name

    /**
    * The setter for the spice
    * @param newPrice the incoming spice data
    */
    public void setPrice(Double newPrice)
    {myPrice = newPrice;}//set Price

    /**
    * the getter for the spice data
    * @return the incoming spice data
    */
    public Double getPrice()
    { return myPrice;}//get node

    /**
    * The setter for the spice
    * @param newQty the incoming spice data
    */
    public void setQty(Integer newQty)
    {myQty = newQty;}//set Qty

    /**
    * the getter for the spice data 
    * @return the incoming spice data
    */
    public Integer getQty()
    { return myQty;}//get node

    /**
    * The setter for the spice
    * @param newUnitPrice the incoming spice data
    */
    public void setUnitPrice(Double newUnitPrice)
    {myUnitPrice = newUnitPrice;}//set unit price

    /**
    * the getter for the spice data 
    * @return the incoming spice data
    */
    public Double getUnitPrice()
    { return myUnitPrice;}//get unit price
    
}//Spice Cordoni Class


\end{lstlisting}

\subsubsection{Description of Spice Code}
\paragraph{} This code for the Spice Class was created by previous knowledge working with the Node Class. Using the same set up each Spice was given a color, price, qty, and unit price. Getters and setters were created for each to make the creation of the spice objects, and the greedy algorithm run more smoothly.


\subsection{Overall:}

\paragraph{} Overall, these directed graph and Greedy Algorithm representations were successful in implementation. To go through each we can create a table for better data understanding, this table will show each and their asymptotic running time:

\begin{center}
\begin{tabular}{ |c|c|c|c| } 
 \hline
 Bellman-Ford & Fractional Knapsack\\ 
 O($VE$) & O($nlog(n)$)\\ 
 \hline
\end{tabular}
\end{center}

\paragraph{} The table above shows a quick understanding of the methods used here. To go into more detail the Bellman Ford Algorithm as an asymptotic running time of  O($VE$), where V is the number of vertices and E is the number of edges. This is because we have to go through each edge and relax each vertex to determine the shortest path. Greedy Algorithms has an asymptotic running time of O($nlog(n)$) with $log$ being of base 2, and n being equal to the size of the array. This is because we have to sort our spice objects from highest to lowest unit price and go through the knapsacks and spices to fill the knapsacks themselves. Overall, we were mostly successful in our implementation of this assignment.




%----------------------------------------------------------------------------------------
%   REFERENCES
%----------------------------------------------------------------------------------------
% The following two commands are all you need in the initial runs of your .Tex file to
% produce the bibliography for the citations in your paper.
\bibliographystyle{abbrv}
\bibliography{lab01} 
% You must have a proper ".bib" file and remember to run:
% latex bibtex latex latex
% to resolve all references.

\pagebreak
\end{document}
